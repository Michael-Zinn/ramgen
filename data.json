{
	"title": "Ravr Code Generation Data",
	"author": "Michael Zinn",
	
	"status": [
		{
			"id": "works",
			"icon": ":white_check_mark:",
			"description": "Works"
		},
		{
			"id": "incomplete",
			"icon": ":neutral_face:",
			"description": "Works with some issues"
		},
		{
			"id": "missing",
			"icon": "  ",
			"description": "Not implemented"
		},
		{
			"id": "rejected",
			"icon": ":heavy_multiplication_x:",
			"description": "Won't be implemented"
		},
		{
			"id": "bonus",
			"icon": ":diamond_shape_with_a_dot_inside:",
			"description": "Bonus function (not inluded in regular Ramda.js)"
		}
	],

	"hide": ["__"],
	"blacklist": ["assocPath", "clone", "type"],

	"functions": [
		{
			"signature": { "generics": [], "type": "Integer", "name": "add", "parameters": ["Integer", "x", "Integer", "y"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "adjust", "parameters": ["Function<A, A>", "f", "Integer", "index", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "all", "parameters": ["Predicate<A>", "predicate", "List<A>", "list"] },
			"status": "works"
		},
		{
			"generate": "unique",
			"signature": { "generics": ["A", "B"], "type": "A", "name": "always", "parameters": ["A", "a", "B", "ignore"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "any", "parameters": ["Predicate<A>", "predicate", "List<A>", "list"] },
			"status": "works"
		},
		{
			"generate": "unique",
			"signature": { "generics": ["A", "B"], "type": "List<B>", "name": "ap", "parameters": ["List<? extends Function<? super A, ? extends B>>", "fs", "List<A>", "as"] },
			"status": "incomplete",
			"comment": "Only works on Lists."
		},
		{
			"generate": "unique",
			"signature": { "generics": ["L", "R", "T"], "type": "T", "name": "applyTuple", "parameters": ["BiFunction<L, R, T>", "f", "Tuple2<L,R>", "tuple"] },
			"status": "incomplete",
			"comment": "Only works on Tuples of size 2 and 3. Will be fixed."
		},
		{
			"generate": "unique",
			"signature": { "generics": ["T1", "T2", "T3", "R"], "type": "R", "name": "applyTuple", "parameters": ["Function3<? super T1, ? super T2, ? super T3, ? extends R>", "f", "Tuple3<T1, T2, T3>", "tuple"] },
			"status": "incomplete",
			"comment": "Only works on Tuples of size 2 and 3. Will be fixed."
		},
		{
			"signature": { "generics": ["A"], "type": "Predicate<A>", "name": "complement", "parameters": ["Predicate<A>", "predicate"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "concat", "parameters": ["List<A>", "list1", "List<A>", "list2"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "concatOptions", "parameters": ["List<Option<A>>"] },
			"status": "bonus"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "contains", "parameters": ["A", "a", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Integer", "name": "count", "parameters": ["Predicate<? super A>", "predicate", "List<A>", "list"] },
			"status": "bonus"
		},
		{
			"signature": { "generics": ["A"], "type": "A", "name": "defaultTo", "parameters": ["A", "a", "Option<A>", "optionA"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "eq", "parameters": ["A", "a1", "A", "a2"] }, "status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "filter", "parameters": ["Predicate<A>", "p", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Integer", "name": "findIndex", "parameters": ["Predicate<A>", "predicate", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A", "B"], "type": "List<B>", "name": "flatMap", "parameters": ["Function<A, List<B>>", "f", "List<A>", "ma"] },
			"status": "incomplete",
			"comment": "Only for lists?"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "forEach", "parameters": ["Consumer<A>", "consumer", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["S", "A"], "type": "A", "name": "get", "parameters": ["Lens<S, A>", "lens", "S", "s"] },
			"status": "works"
		},
		{
			"signature": {
				"generics": ["A", "B"],
				"type": "Map<B, List<A>>", "name": "groupBy", "parameters": ["Function<? super A, ? extends B>", "classifier", "List<A>", "list"]
			},
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Option<A>", "name": "head", "parameters": ["List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type":"A", "name":"identity", "parameters": ["A", "a"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A", "B"], 
				"type": "B", "name": "ifElse", "parameters": [ "Predicate<A>", "predicate", "Function<A, B>", "then", "Function<A, B>", "els", "A", "value" ]
			},
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "isNone", "parameters": ["Option<A>", "any"] },
			"status": "works",
			"comment": "Replacement for isNil, returns true for Option.none()."
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "isSome", "parameters": ["Option<A>", "any"] },
			"status": "works",
			"comment": "Replacement for complement(isNil), returns true for Option.some(\"whatever\")."
		},
		{
			"signature": { "generics": ["A"], "type": "String", "name": "join", "parameters": ["String", "joiner", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Option<String>", "name": "joinOption", "parameters": ["String", "joiner", "List<A>", "list"] },
			"status": "bonus",
			"comment": "Like join, except that it returns nothing when joining empty lists."
		},
		{
			"generate": "none",
			"signature": { "generics": ["S", "A"], "type": "Lens<S, A>", "name": "lens", "parameters": ["Function<S, A>", "getter", "BiConsumer<S, A>", "setter"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A", "B"], "type": "List<B>", "name": "map", "parameters": ["Function<A, B>", "f", "List<A>", "value"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "Boolean", "name": "none", "parameters": ["Predicate<A>", "predicate", "List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": [], "type": "Boolean", "name": "not", "parameters": ["Boolean", "b"] },
			"status": "works"
		},
		{
			"generate": "none",
			"signature": { "generics": ["T"], "type": "T", "name": "nullTo", "parameters": ["T", "fallback", "T", "nullable"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["S extends Copyable<S>", "A"], "type": "S", "name": "over", "parameters": ["Lens<S, A>", "lens", "Function<A, A>", "f", "S", "x"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "reverse", "parameters": ["List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["S extends Copyable<S>", "A"], "type": "S", "name": "set", "parameters": ["Lens<S, A>", "lens", "A", "value", "S", "object"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["A"], "type": "List<A>", "name": "tail", "parameters": ["List<A>", "list"] },
			"status": "works"
		},
		{
			"signature": { "generics": [], "type": "String", "name": "toLower", "parameters": ["String", "s"] },
			"status": "works" },
		{
			"signature": { "generics": [], "type": "String", "name": "toUpper", "parameters": ["String", "s"] },
			"status": "works" },
		{
			"signature": { "generics": ["A", "B"], "type": "List<Tuple2<A, B>>", "name": "zip", "parameters": ["List<A>", "a", "List<B>", "b"] },
			"status": "works"
		},
		{
			"signature": { "generics": ["T", "U", "R"], "type": "List<R>", "name": "zipWith", "parameters": ["BiFunction<T, U, R>", "biFunction", "List<T>", "t", "List<U>", "u"] },
			"status": "works"
		}
	]

}
                                                                                                 
			
